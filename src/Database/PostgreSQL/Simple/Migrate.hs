
-- |
-- Module      : Database.PostgreSQL.Simple.Migrate
-- Description : Yet another migration tool for Haskell/PostgreSQL projects.
-- Copyright   : (c) Brian Hurt, 2023
-- License     : None
-- Maintainer  : Brian Hurt <bhurt42@gmail.com>
-- Stability   : experimental
--
-- = Justification
--
-- Given that there are already several very good SQL schema management
-- tools (such as Liquibase) and several Haskell libraries for doing
-- schema management, why write another one?
--
-- The answer is that psql-migrate has a different philosophy for
-- maintaining the schema.  Rather than being a separate tool with
-- separate data from the main program, it's designed to integrate
-- into the code.  Migrations are just another data structure,
-- intendend to live right along side the other data structures and
-- functions that depend on them.
--
-- This change in philosophy gives rise to four unusual features:
-- dependencies, phases, optional, and replaces.
--
-- = __Introduction__
--
-- == Migrations
--
-- The core structure to this module is the `Migration`.  A migration is
-- a single change to the database to be applied atomically.  It has two
-- required values- the name of the migration and the migration command-
-- as well as several additional optional values.
--
-- The name of the migration is just a string, which uniquely identifies
-- the migration.  The name should be unique in any set of changes.  It
-- is used to both test whether the migration has been applied or not,
-- and to express dependencies between migrations.  
--
-- The command is just the SQL to be execute to apply the migration to
-- a database, and is a `Database.PostgreSQL.Simple.Query`.  We recommend
-- using the `Database.PostgreSQL.Simple.SqlQQ.sql` quasiquoter for
-- convience.
--
-- To make declaring migrations simple, we supply the `makeMigration`
-- function.  This takes a name and command to execute, making a
-- simple migration just:
--
-- @
--     makeMigration "example-1"
--        [sql| CREATE TABLE foo(
--                 bar INT PRIMARY KEY); |]
-- @
--
-- There are several optional fields, which can be set with various
-- update functions.  The modifier functions are designed to be used
-- with Haskell's backtick function application.  So, for example, a
-- more complicated migration might be:
--
-- @
--     makeMigration "example-2"
--         [sql| ALTER TABLE foo ADD COLUMN baz VARCHAR; |]
--         \`addDependency\` "example-1"
--         \`setPhase\` 2
-- @
--
-- Don't worry about what they do at the moment- the important point is
-- that `addDependency` and `setPhase` are just functions that modify
-- the migration created by `makeMigration`.
--
-- Once we have a list of migrations, we can apply them to a database
-- using the `apply` function, of check to ensure they have been
-- applied using the `check` function.
--
-- == Schema in Code
--
-- The key concept here is that a Migration is just a plain Haskell
-- structure.  The huge advantage of migrations being just structures
-- is that the migrations can live in the source code, next to the
-- functions and data structures which use that schema.  For example,
-- we might have a user module defined like:
--
-- @
-- module User where
--
--     data User = User {
--                  userId   :: Int,
--                  userName :: String }
--
--     getUser :: Connection -> Int -> IO User
--     getUser = ...
-- 
--     migrations :: [ Migration ]
--     migration = [
--          makeMigration "user-1"
--              [sql| CREATE TABLE users(
--                      id SERIAL PRIMARY KEY,
--                      name VARCHAR NOT NULL); |]
--          ]
-- @
--
-- Keeping the schema next to the code that uses it makes it significantly
-- easier to keep both in sync.
--
-- The order the migrations appear in the list does not matter.  So, when
-- we `apply` the migrations to a database or `check` if they have been
-- applied, we can just concatenate all the individual migration lists
-- together.
--
-- == Explicit Dependencies
--
-- It is important that the order that migrations appear in the list
-- not matter, as that allows us to move the migrations to live with
-- the most relevant module.  But the order in which some migrations
-- are applied does matter- you can add a column to a table before the
-- table itself is created.
--
-- The solution to this is to use explicit dependencies.  The
-- `addDependency` function is used to add a dependency to a migration:
-- 
-- @
-- module User where
--
--     migrations :: [ Migration ]
--     migration = [
--          makeMigration "user-1"
--              [sql| CREATE TABLE users(
--                      id SERIAL PRIMARY KEY,
--                      name VARCHAR NOT NULL); |],
--          makeMigration "user-2"
--              [sql| ALTER TABLE users
--                      ADD COLUMN password VARCHAR; |]
--              \`addDependency\` "user-1"
--          ]
-- @
-- 
-- Here, the user-2 migration explicitly depends upon the user-1 migration-
-- and `apply` will ensure that user-1 is applied first.  We need to create
-- the table before we add the new column.  As a side note, it's very bad
-- practice to store passwords in plain text in your database- we're doing
-- it here just for example purposes.
--
-- This creates a partial ordering of migrations.  For example, we might
-- have a migration that creates a messages table, that also depends upon
-- the \"user-1\" migration:
--
-- @
--  module Messages where
--
--      migrations :: [ Migration ]
--      migrations = [
--          makeMigration "messages-1"
--              [sql| CREATE TABLE messages (
--                          id SERIAL PRIMARY KEY,
--                          author INT NOT NULL REFERENCES users(id),
--                          message VARCHAR ); |]
--              \`addDependency\` "user-1"
--      ]
-- @
--
-- In this case- the \"user-1\" migration needs to be applied before
-- either the \"messages-1\" and \"user-2\" are applied- but what
-- order \"messages-1\" and \"user-2\" are applied is not specified.
-- And indeed, it does not matter.
--
-- == Optional Migrations
--
-- There is a chicken or the egg problem in applying new migrations
-- to a database that is actively being used.  Do you update the program
-- that is using the database first, or apply the schema changes first? 
-- Updating the program first can cause problems as it tries to use
-- schema changes that haven't been applied yet.  But applying the schema
-- first has the same problem- the program is now not aware of the
-- schema changes.
--
-- The solution is to be able to mark certain migrations as optional.
-- This means they may or may not have been applied (yet).  We can then
-- write our server to test (if needed) whether or not the optional
-- migration has been applied.
--
-- So, say we are adding passwords to our application.  We create a
-- new migration add the password column to the table:
--
-- @
-- module User where
--
--     migrations :: [ Migration ]
--     migration = [
--          ...
--          makeMigration "user-2"
--              [sql| ALTER TABLE users
--                      ADD COLUMN password VARCHAR; |]
--              \`addDependency\` "user-1"
--              \`setOptional\` Optional
--          ]
-- @
--
-- The @\`setOptional\` Optional@ marks the migration as optional.  We
-- can then check whether the migration has been applied or not:
--
-- @
--      checkPassword :: PG.Connection
--                          -> Int
--                          -> String
--                          -> IO Bool
--      checkPassword conn userId pword = do
--          PG.withTransaction conn $ do
--              migApplied :: Bool <- migrationIsApplied conn "user-2"
--              if migApplied
--              then do
--                  res <- PG.query conn
--                            [sql| SELECT password FROM users
--                                   WHERE id = ? LIMIT 1; |]
--                            (PG.Only userId)
--                  case res of
--                     (PG.Only (Just pwd)) : _ -> pure (pwd == pword)
--                     (PG.Only Nothing   ) : _ -> pure (pword == \"kumquat\")
--                     []                       -> pure False
--              else
--                  pure $ pword == \"kumquat\"
-- @
--
-- Here we call `migrationIsApplied` to check if we've added the password
-- column yet or not.  If we haven't, we just assume all passwords are
-- \"kumquat\" (not good security, again and for the record).  Once
-- we've applied the migration and the password column now exists, we
-- use it.
--
-- This solves the chicked and the egg problem.  We can now deploy this
-- server with the old schema (the one without the password column), and
-- it works fine.  Once we've upgraded all the servers, we can then apply
-- the migrations, adding the new column.  The nanosecond we do, the
-- servers all start using the new column.  Then, at some later date,
-- we can drop the optional flag from this migration.
--
-- It is possible, indeed likely, that a single change can require multiple
-- rounds of optional migrations.  For example, we probably really want
-- the password field to be non-nullable (allowing us to get rid of the
-- default \"kumquat\" password).
--
-- == Replaces
--
-- Migrations serve multiple purposes- they document what the current
-- schema is, how to recreate the database from scratch, and what the
-- recent changes to the schema are.  But one thing it does not need to
-- do is be a record of all database changes ever.  We have version
-- control for that.
--
-- Indeed, attempting to retain a complete history of database
-- schema changes obstructs the other, more important, purposes.
-- Compare this set of migrations:
--
-- @
--     migrations :: [ Migration ]
--     migration = [
--          makeMigration "user-1"
--              [sql| CREATE TABLE users(
--                      id SERIAL PRIMARY KEY,
--                      name VARCHAR NOT NULL); |],
--          makeMigration "user-2"
--              [sql| ALTER TABLE users
--                      ADD COLUMN password VARCHAR; |]
--              \`addDependency\` "user-1",
--          makeMigration "user-3"
--              [sql| ALTER TABLE users
--                      ADD COLUMN email VARCHAR; |]
--              \`addDependency\` "user-1",
--          makeMigration "user-4"
--              [sql| ALTER TABLE users
--                      ALTER COLUMN password
--                      SET NOT NULL; |]
--              \`addDependency\` "user-2"
--          ]
-- @
--
-- Compared to this, equivalent, list of migrations:
--
-- @
--     migration = [
--          makeMigration "user-1"
--              [sql| CREATE TABLE users(
--                      id SERIAL PRIMARY KEY,
--                      name VARCHAR NOT NULL,
--                      password VARCHAR NOT NULL,
--                      email VARCHAR); |]
--          ]
-- @
--
-- The second migration list is clearly preferrable to the first- it's
-- easier to see what the current schema is, faster to apply to a new
-- database, and uses less memory. And this is a pretty simple example
-- compared to what happens in reality.
--
-- The solution here is to use the replaces feature.  We can define
-- a given migration to replace some set of previous migrations:
--
-- @
--      migration = [
--          makeMigration "user-5"
--              [sql| CREATE TABLE users(
--                      id SERIAL PRIMARY KEY,
--                      name VARCHAR NOT NULL,
--                      password VARCHAR NOT NULL,
--                      email VARCHAR); |]
--          \`addReplaces\` [
--              makeReplaces "users-1"
--                  "9wbC-yXz6ISXeA-eFOn-l4DVoJZ4P8I79HJxJKHIBIg=",
--              makeReplaces "users-2"
--                  "t_isz1eBAu8XM_e2idYdnCPvI-UFEpFC3s2RTyjArDA=",
--              makeReplaces "users-3"
--                  "wL4RJs17fjpSEvogt4RdoLk1LvfzfAZ2IVabbuwKOcE=",
--              makeReplaces "users-4"
--                  "F8_nmgURLqBjyQfKEOZAL4ugZhZxYyGPqPA3Rbtk3sI=" 
--          ]
--      ]
-- @
--
-- This says that our new \"user-5\" migration replaces the old
-- \"user-1\" through \"user-4\" migrations.
--
-- The concept here is that applying the \"user-5\" migration acheives
-- the same effect as applying the \"user-1\" through \"user-4\"
-- migrations (in some order).  That the single migration \"user-5\"
-- replaces the four migrations \"user-1\" through \"user-4\".
--
-- When the \"user-5\" migration is applied, if none of the replaced
-- migrations have been applied, then the SQL command is run and \"user-5\"
-- is added to the schema_migrations table, marking it as applied.
-- If all of the replaced migrations have been applied, then the SQL
-- command is NOT run, the replaced migrations are deleted from the
-- schema_migrations table, and \"user-5\" is added.  It is an error
-- for some of the replaced mgirations to have been applied when others
-- have not (although see the `setReplacesOptional` command for when
-- this is OK).
--
-- __WARNING__: The assumption is that the command, when executed,
-- will result the same schema as the aggregate result of applying
-- all the replaced migrations.  For obvious reasons this condition
-- is not checked for.  Violating it, however, will result in tears
-- and recriminations.  Use this feature at your own risk.
--
-- The \"9wbC-blahblahblah\" stuff is the fingerprint of the migration
-- (the base-64 encoding of the SHA3-256 hash of the command).  This
-- can be obtained either by calling the `makeFingerprint` command,
-- using the `fingerprint` field of the migration structure, or getting
-- the fingerprint out of the database.
--
-- Note that the @replaces@ field is not part of the fingerprint.
-- So, after you are sure all databases have been upgraded, you
-- can quietly drop the replaces field, and move forward with
-- your cleaner migration list.
--
-- == Phases
--
-- Dependencies are the primary way to order migrations.  But some
-- times, some migrations just want to happen before or after everything
-- else.  For example, you might want to create a dbtype table, labelling
-- the database as production, test, or development:
--
-- @
--  migrations :: [ Migration ]
--  migrations = [
--      makeMigration "dbtype-1"
--          [sql| CREATE TABLE dbtype(
--                  only_row BOOL PRIMARY KEY
--                              DEFAULT TRUE,
--                  dbtype TEXT NOT NULL,
--                  CONSTRAINT only_one_row
--                      CHECK (only_row); |]
--          \`setPhase\` 0,
--      makeMigration "db-type-insert-1"
--          [sql| INSERT INTO dbtype(dbtype)
--                  VALUES(\'development\'); |]
--          \`addDependency\` "dbtype-1"
--          \`setPhase\` 0
--      ]
-- @
--
-- We want these migrations to run first, before everything else.  We
-- could just add a dependency to \"db-type-insert-1\" to every other
-- constraint, or we could use phases.
--
-- Every migration has a phase.  By default, `makeMigration` sets this
-- phase to 1, which is generally correct.  The rule is: every migration
-- of phase N happens before any migration of phase N+1 happens.  So
-- by setting these migrations to be phase 0, they will happen \"first\".
--
-- == Reading SQL From a File
--
-- Although it is generally considered good practice to have the schema
-- modification commands directly in the file (either via overloaded
-- strings or the sql quasiquoter), some times external factors require
-- the schema commands be loaded from an external file.
--
-- In this case, you can use the
-- [file-embed library](https://hackage.haskell.org/package/file-embed-0.0.16.0/docs/Data-FileEmbed.html)
-- to load the file into the executable at compile time.  For example,
-- you can load a raw query like this:
--
-- @
-- {-# LANGUAGE TemplateHaskell #-}
-- module Foo (migrations) where
--
--     import           Database.PostgreSQL.Simple.Migrate
--     import           Database.PostgreSQL.Simple.Types   (Query(..))
--     import           Data.ByteString                    (ByteString)
--     import           Data.FileEmbed                     (embedFile)
--     
--     myFile :: ByteString
--     myFile = $(embedFile "myquery.sql")
--
--     migrations :: [ Migration ]
--     migrations = [
--         makeMigration "mig-1" (Query myFile)
--     ]
-- @
--
-- A more powerful way to accomplish the same goal is to take advantage
-- of the `Data.Aeson.FromJSON` instance on the `Migration` type, and
-- do:
--
-- @
-- {-# LANGUAGE TemplateHaskell #-}
-- module Foo (migrations) where
--
--     import           Data.Aeson                         (decode)
--     import           Database.PostgreSQL.Simple.Migrate
--     import           Data.ByteString                    (ByteString)
--     import qualified Data.ByteString.Lazy               as Lazy
--     import           Data.FileEmbed                     (embedFile)
--     
--     myFile :: ByteString
--     myFile = $(embedFile "myquery.sql")
--
--     migrations :: [ Migration ]
--     migrations = 
--         case decode myFile of
--             Nothing -> error "Error decoding myquery.sql"
--             Just xs -> xs
-- @
--
-- A minimal migration, in JSON, would be:
--
-- @
-- {
--   "name": "foo",
--   "command": "SQL goes here"
-- }
-- @
--
-- A maximal migration, in JSON, would be:
--
-- @
-- {
--   "name":"foo",
--   "command":"Example SQL",
--   "deps":["bar","baz"],
--   "optional":true,
--   "phase":3,
--   "replaces":
--   [
--     {
--       "name":"alpha",
--       "fingerprint":"rJqW8fvpg6kMVD3-QgMyeqsHNey_eqI5BNzRjSZD3d4="
--     },
--     {
--       "name":"beta",
--       "fingerprint":"htmzbT5XHDNwez6ITdlkG5hJpPWjir_47U8u4I-5v2c=",
--       "optional":true
--     }
--   ]
-- }
-- @
--

module Database.PostgreSQL.Simple.Migrate (
    -- * Migration type
    Migration(..),
    Optional(..),
    Replaces(..),

    -- * Creating migrations
    makeMigration,
    makeReplaces,

    -- ** Migration modifiers
    addDependency,
    addDependencies,
    setOptional,
    setPhase,
    addReplaces,

    -- ** Replaces modifiers
    setReplacesOptional,

    -- * Applying migrations
    apply,
    check,
    Verbose(..),

    -- * Handling Errors
    MigrationsError,
    formatMigrationsError,

    -- * Checking for Optional migrations
    migrationIsApplied,
    appliedOptionalMigrations,

    -- * Calculating fingerprints
    --
    -- | Useful for constructing `Replaces` structures.
    --
    makeFingerprint
) where

    import Database.PostgreSQL.Simple.Migrate.Internal.Apply
    import Database.PostgreSQL.Simple.Migrate.Internal.Error
    import Database.PostgreSQL.Simple.Migrate.Internal.Finger
    import Database.PostgreSQL.Simple.Migrate.Internal.Opt
    import Database.PostgreSQL.Simple.Migrate.Internal.Types
